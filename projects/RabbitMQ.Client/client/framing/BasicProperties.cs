// This source code is dual-licensed under the Apache License, version
// 2.0, and the Mozilla Public License, version 2.0.
//
// The APL v2.0:
//
//---------------------------------------------------------------------------
//   Copyright (c) 2007-2020 VMware, Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//---------------------------------------------------------------------------
//
// The MPL v2.0:
//
//---------------------------------------------------------------------------
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
//
//  Copyright (c) 2007-2020 VMware, Inc.  All rights reserved.
//---------------------------------------------------------------------------

using System;
using System.Buffers;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;

using RabbitMQ.Client.Impl;
using RabbitMQ.Util;

namespace RabbitMQ.Client.Framing
{
    /// <summary>Autogenerated type. AMQP specification content header properties for content class "basic"</summary>
    internal sealed class BasicProperties : RabbitMQ.Client.Impl.BasicProperties
    {
        private readonly ReadOnlyMemory<byte> _readOnlyMemory = ReadOnlyMemory<byte>.Empty;
        private string _contentType;
        private string _contentEncoding;
        private IDictionary<string, object> _headers;
        private byte _deliveryMode;
        private byte _priority;
        private string _correlationId;
        private string _replyTo;
        private string _expiration;
        private string _messageId;
        private AmqpTimestamp _timestamp;
        private string _type;
        private string _userId;
        private string _appId;
        private string _clusterId;

        public override string ContentType
        {
            get
            {
                if (_contentType == default && IsContentTypePresent())
                {
                    WireFormatting.ReadShortstr(_readOnlyMemory.Span.Slice(ContentTypeOffset), out _contentType);
                }

                return _contentType;
            }
            set => _contentType = value;
        }

        public override string ContentEncoding
        {
            get
            {
                if (_contentEncoding == default && IsContentEncodingPresent())
                {
                    WireFormatting.ReadShortstr(_readOnlyMemory.Span.Slice(ContentEncodingOffset), out _contentEncoding);
                }

                return _contentEncoding;
            }
            set => _contentEncoding = value;
        }

        public override IDictionary<string, object> Headers
        {
            get
            {
                if (_headers == default && IsHeadersPresent())
                {
                    WireFormatting.ReadDictionary(_readOnlyMemory.Span.Slice(HeadersOffset), out Dictionary<string, object> tempDirectory);
                    _headers = tempDirectory;
                }

                return _headers;
            }
            set => _headers = value;
        }

        public override byte DeliveryMode
        {
            get
            {
                if (_deliveryMode == default && IsDeliveryModePresent())
                {
                    _deliveryMode = _readOnlyMemory.Span[DeliveryModeOffset];
                }

                return _deliveryMode;
            }
            set => _deliveryMode = value;
        }

        public override byte Priority
        {
            get
            {
                if (_priority == default && IsPriorityPresent())
                {
                    _priority = _readOnlyMemory.Span[PriorityOffset];
                }

                return _priority;
            }
            set => _priority = value;
        }

        public override string CorrelationId
        {
            get
            {
                if (_correlationId == default && IsCorrelationIdPresent())
                {
                    WireFormatting.ReadShortstr(_readOnlyMemory.Span.Slice(CorrelationIdOffset), out _correlationId);
                }

                return _correlationId;
            }
            set => _correlationId = value;
        }

        public override string ReplyTo
        {
            get
            {
                if (_replyTo == default && IsReplyToPresent())
                {
                    WireFormatting.ReadShortstr(_readOnlyMemory.Span.Slice(ReplyToOffset), out _replyTo);
                }

                return _replyTo;
            }
            set => _replyTo = value;
        }

        public override string Expiration
        {
            get
            {
                if (_expiration == default && IsExpirationPresent())
                {
                    WireFormatting.ReadShortstr(_readOnlyMemory.Span.Slice(ExpirationOffset), out _expiration);
                }

                return _expiration;
            }
            set => _expiration = value;
        }

        public override string MessageId
        {
            get
            {
                if (_messageId == default && IsMessageIdPresent())
                {
                    WireFormatting.ReadShortstr(_readOnlyMemory.Span.Slice(MessageIdOffset), out _messageId);
                }

                return _messageId;
            }
            set => _messageId = value;
        }

        public override AmqpTimestamp Timestamp
        {
            get
            {
                if (_timestamp == default && IsTimestampPresent())
                {
                    WireFormatting.ReadTimestamp(_readOnlyMemory.Span.Slice(TimestampOffset), out _timestamp);
                }

                return _timestamp;
            }
            set => _timestamp = value;
        }

        public override string Type
        {
            get
            {
                if (_type == default && IsTypePresent())
                {
                    WireFormatting.ReadShortstr(_readOnlyMemory.Span.Slice(TypeOffset), out _type);
                }

                return _type;
            }
            set => _type = value;
        }

        public override string UserId
        {
            get
            {
                if (_userId == default && IsUserIdPresent())
                {
                    WireFormatting.ReadShortstr(_readOnlyMemory.Span.Slice(UserIdOffset), out _userId);
                }

                return _userId;
            }
            set => _userId = value;
        }

        public override string AppId
        {
            get
            {
                if (_appId == default && IsAppIdPresent())
                {
                    WireFormatting.ReadShortstr(_readOnlyMemory.Span.Slice(AppIdOffset), out _appId);
                }

                return _appId;
            }
            set => _appId = value;
        }

        public override string ClusterId
        {
            get
            {
                if (_clusterId == default && IsClusterIdPresent())
                {
                    WireFormatting.ReadShortstr(_readOnlyMemory.Span.Slice(ClusterIdOffset), out _clusterId);
                }

                return _clusterId;
            }
            set => _clusterId = value;
        }

        public override void ClearContentType() => _contentType = default;

        public override void ClearContentEncoding() => _contentEncoding = default;

        public override void ClearHeaders() => _headers = default;

        public override void ClearDeliveryMode() => _deliveryMode = default;

        public override void ClearPriority() => _priority = default;

        public override void ClearCorrelationId() => _correlationId = default;

        public override void ClearReplyTo() => _replyTo = default;

        public override void ClearExpiration() => _expiration = default;

        public override void ClearMessageId() => _messageId = default;

        public override void ClearTimestamp() => _timestamp = default;

        public override void ClearType() => _type = default;

        public override void ClearUserId() => _userId = default;

        public override void ClearAppId() => _appId = default;

        public override void ClearClusterId() => _clusterId = default;

        public override bool IsContentTypePresent() => _contentType != default || (_readOnlyMemory.Length > 0 && (_readOnlyMemory.Span[0] & 0b1000_0000) != 0);

        public override bool IsContentEncodingPresent() => _contentEncoding != default || (_readOnlyMemory.Length > 0 && (_readOnlyMemory.Span[0] & 0b0100_0000) != 0);

        public override bool IsHeadersPresent() => _headers != default || (_readOnlyMemory.Length > 0 && (_readOnlyMemory.Span[0] & 0b0010_0000) != 0);

        public override bool IsDeliveryModePresent() => _deliveryMode != default || (_readOnlyMemory.Length > 0 && (_readOnlyMemory.Span[0] & 0b0001_0000) != 0);

        public override bool IsPriorityPresent() => _priority != default || (_readOnlyMemory.Length > 0 && (_readOnlyMemory.Span[0] & 0b0000_1000) != 0);

        public override bool IsCorrelationIdPresent() => _correlationId != default || (_readOnlyMemory.Length > 0 && (_readOnlyMemory.Span[0] & 0b0000_0100) != 0);

        public override bool IsReplyToPresent() => _replyTo != default || (_readOnlyMemory.Length > 0 && (_readOnlyMemory.Span[0] & 0b0000_0010) != 0);

        public override bool IsExpirationPresent() => _expiration != default || (_readOnlyMemory.Length > 0 && (_readOnlyMemory.Span[0] & 0b0000_0001) != 0);

        public override bool IsMessageIdPresent() => _messageId != default || (_readOnlyMemory.Length > 1 && (_readOnlyMemory.Span[1] & 0b1000_0000) != 0);

        public override bool IsTimestampPresent() => _timestamp != default || (_readOnlyMemory.Length > 1 && (_readOnlyMemory.Span[1] & 0b0100_0000) != 0);

        public override bool IsTypePresent() => _type != default || (_readOnlyMemory.Length > 1 && (_readOnlyMemory.Span[1] & 0b0010_0000) != 0);

        public override bool IsUserIdPresent() => _userId != default || (_readOnlyMemory.Length > 1 && (_readOnlyMemory.Span[1] & 0b0001_0000) != 0);

        public override bool IsAppIdPresent() => _appId != default || (_readOnlyMemory.Length > 1 && (_readOnlyMemory.Span[1] & 0b0000_1000) != 0);

        public override bool IsClusterIdPresent() => _clusterId != default || (_readOnlyMemory.Length > 1 && (_readOnlyMemory.Span[1] & 0b0000_0100) != 0);

        private int ContentTypeOffset => 2;
        private int ContentEncodingOffset => ContentTypeOffset + (IsContentTypePresent() ? _readOnlyMemory.Span[ContentTypeOffset] + 1 : 0);
        private int HeadersOffset => ContentEncodingOffset + (IsContentEncodingPresent() ? _readOnlyMemory.Span[ContentEncodingOffset] + 1 : 0);
        private int DeliveryModeOffset => HeadersOffset + (IsHeadersPresent() ? (int)NetworkOrderDeserializer.ReadUInt32(_readOnlyMemory.Span.Slice(HeadersOffset)) + 4 : 0);
        private int PriorityOffset => DeliveryModeOffset + (IsDeliveryModePresent() ? 1 : 0);
        private int CorrelationIdOffset => PriorityOffset + (IsPriorityPresent() ? 1 : 0);
        private int ReplyToOffset => CorrelationIdOffset + (IsCorrelationIdPresent() ? _readOnlyMemory.Span[CorrelationIdOffset] + 1 : 0);
        private int ExpirationOffset => ReplyToOffset + (IsReplyToPresent() ? _readOnlyMemory.Span[ReplyToOffset] + 1 : 0);
        private int MessageIdOffset => ExpirationOffset + (IsExpirationPresent() ? _readOnlyMemory.Span[ExpirationOffset] + 1 : 0);
        private int TimestampOffset => MessageIdOffset + (IsMessageIdPresent() ? _readOnlyMemory.Span[MessageIdOffset] + 1 : 0);
        private int TypeOffset => TimestampOffset + (IsTimestampPresent() ? 8 : 0);
        private int UserIdOffset => TypeOffset + (IsTypePresent() ? _readOnlyMemory.Span[TypeOffset] + 1 : 0);
        private int AppIdOffset => UserIdOffset + (IsUserIdPresent() ? _readOnlyMemory.Span[UserIdOffset] + 1 : 0);
        private int ClusterIdOffset => AppIdOffset + (IsAppIdPresent() ? _readOnlyMemory.Span[AppIdOffset] + 1 : 0);


        public BasicProperties()
        {
        }

        public BasicProperties(ReadOnlyMemory<byte> memory)
        {
            _readOnlyMemory = memory;
        }

        public override ushort ProtocolClassId => 60;
        public override string ProtocolClassName => "basic";

        internal override int WritePropertiesTo(Span<byte> span)
        {
            int offset = WireFormatting.WriteBits(span,
                IsContentTypePresent(), IsContentEncodingPresent(), IsHeadersPresent(), IsDeliveryModePresent(), IsPriorityPresent(),
                IsCorrelationIdPresent(), IsReplyToPresent(), IsExpirationPresent(), IsMessageIdPresent(), IsTimestampPresent(),
                IsTypePresent(), IsUserIdPresent(), IsAppIdPresent(), IsClusterIdPresent());
            if (IsContentTypePresent()) { offset += WireFormatting.WriteShortstr(span.Slice(offset), _contentType); }
            if (IsContentEncodingPresent()) { offset += WireFormatting.WriteShortstr(span.Slice(offset), _contentEncoding); }
            if (IsHeadersPresent()) { offset += WireFormatting.WriteTable(span.Slice(offset), _headers); }
            if (IsDeliveryModePresent()) { span[offset++] = _deliveryMode; }
            if (IsPriorityPresent()) { span[offset++] = _priority; }
            if (IsCorrelationIdPresent()) { offset += WireFormatting.WriteShortstr(span.Slice(offset), _correlationId); }
            if (IsReplyToPresent()) { offset += WireFormatting.WriteShortstr(span.Slice(offset), _replyTo); }
            if (IsExpirationPresent()) { offset += WireFormatting.WriteShortstr(span.Slice(offset), _expiration); }
            if (IsMessageIdPresent()) { offset += WireFormatting.WriteShortstr(span.Slice(offset), _messageId); }
            if (IsTimestampPresent()) { offset += WireFormatting.WriteTimestamp(span.Slice(offset), _timestamp); }
            if (IsTypePresent()) { offset += WireFormatting.WriteShortstr(span.Slice(offset), _type); }
            if (IsUserIdPresent()) { offset += WireFormatting.WriteShortstr(span.Slice(offset), _userId); }
            if (IsAppIdPresent()) { offset += WireFormatting.WriteShortstr(span.Slice(offset), _appId); }
            if (IsClusterIdPresent()) { offset += WireFormatting.WriteShortstr(span.Slice(offset), _clusterId); }
            return offset;
        }

        public override int GetRequiredPayloadBufferSize()
        {
            int bufferSize = 2; // number of presence fields (14) in 2 bytes blocks
            if (IsContentTypePresent()) { bufferSize += 1 + Encoding.UTF8.GetByteCount(_contentType); } // _contentType in bytes
            if (IsContentEncodingPresent()) { bufferSize += 1 + Encoding.UTF8.GetByteCount(_contentEncoding); } // _contentEncoding in bytes
            if (IsHeadersPresent()) { bufferSize += WireFormatting.GetTableByteCount(_headers); } // _headers in bytes
            if (IsDeliveryModePresent()) { bufferSize++; } // _deliveryMode in bytes
            if (IsPriorityPresent()) { bufferSize++; } // _priority in bytes
            if (IsCorrelationIdPresent()) { bufferSize += 1 + Encoding.UTF8.GetByteCount(_correlationId); } // _correlationId in bytes
            if (IsReplyToPresent()) { bufferSize += 1 + Encoding.UTF8.GetByteCount(_replyTo); } // _replyTo in bytes
            if (IsExpirationPresent()) { bufferSize += 1 + Encoding.UTF8.GetByteCount(_expiration); } // _expiration in bytes
            if (IsMessageIdPresent()) { bufferSize += 1 + Encoding.UTF8.GetByteCount(_messageId); } // _messageId in bytes
            if (IsTimestampPresent()) { bufferSize += 8; } // _timestamp in bytes
            if (IsTypePresent()) { bufferSize += 1 + Encoding.UTF8.GetByteCount(_type); } // _type in bytes
            if (IsUserIdPresent()) { bufferSize += 1 + Encoding.UTF8.GetByteCount(_userId); } // _userId in bytes
            if (IsAppIdPresent()) { bufferSize += 1 + Encoding.UTF8.GetByteCount(_appId); } // _appId in bytes
            if (IsClusterIdPresent()) { bufferSize += 1 + Encoding.UTF8.GetByteCount(_clusterId); } // _clusterId in bytes
            return bufferSize;
        }

        internal override void TryCleanup()
        {
            if (_readOnlyMemory.Length > 0 && MemoryMarshal.TryGetArray(_readOnlyMemory, out ArraySegment<byte> segment))
            {
                ArrayPool<byte>.Shared.Return(segment.Array);
            }
        }
    }
}

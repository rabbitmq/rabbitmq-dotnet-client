// Autogenerated code. Do not edit.

// This source code is dual-licensed under the Apache License, version
// 2.0, and the Mozilla Public License, version 1.1.
//
// The APL v2.0:
//
//---------------------------------------------------------------------------
//   Copyright (C) 2007-2014 GoPivotal, Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//---------------------------------------------------------------------------
//
// The MPL v1.1:
//
//---------------------------------------------------------------------------
//   The contents of this file are subject to the Mozilla Public License
//   Version 1.1 (the "License"); you may not use this file except in
//   compliance with the License. You may obtain a copy of the License at
//   http://www.RabbitMQ.com/mpl.html
//
//   Software distributed under the License is distributed on an "AS IS"
//   basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//   License for the specific language governing rights and limitations
//   under the License.
//
//   The Original Code is RabbitMQ.
//
//   The Initial Developer of the Original Code is GoPivotal, Inc.
//   Copyright (c) 2007-2014 GoPivotal, Inc.  All rights reserved.
//---------------------------------------------------------------------------

using RabbitMQ.Client.Exceptions;

namespace RabbitMQ.Client.Framing.Impl
{
    using RabbitMQ.Client.Framing;
    using System.Threading.Tasks;
    
    public partial class Model : RabbitMQ.Client.Impl.ModelBase
    {
        public override Task ConnectionTuneOkAsync(ushort @channelMax, uint @frameMax, ushort @heartbeat)
        {
            return ModelSendAsync(new ConnectionTuneOk(@channelMax, @frameMax, @heartbeat) , null, null);
        }
        //public override async Task ConnectionTuneOkAsync(ushort @channelMax, uint @frameMax, ushort @heartbeat)
        //{
        //    ConnectionTuneOk __req = new ConnectionTuneOk(@channelMax, @frameMax, @heartbeat);
        //    //__req.m_channelMax = @channelMax;
        //    //__req.m_frameMax = @frameMax;
        //    //__req.m_heartbeat = @heartbeat;
        //    await ModelSendAsync(__req, null, null);
        //}
        public override Task _Private_ConnectionOpenAsync(string @virtualHost, string @capabilities, bool @insist)
        {
            return ModelSendAsync(new ConnectionOpen(@virtualHost, @capabilities, @insist), null, null);
        }
        public override async Task _Private_ConnectionCloseAsync(ushort @replyCode, string @replyText, ushort @classId, ushort @methodId)
        {
            ConnectionClose __req = new ConnectionClose();
            __req.m_replyCode = @replyCode;
            __req.m_replyText = @replyText;
            __req.m_classId = @classId;
            __req.m_methodId = @methodId;
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            ConnectionCloseOk __rep = __repBase as ConnectionCloseOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override Task _Private_ConnectionCloseOkAsync()
        {
            return ModelSendAsync(new ConnectionCloseOk(), null, null);
        }
        public override async Task _Private_ExchangeDeclareAsync(
          string @exchange,
          string @type,
          bool @passive,
          bool @durable,
          bool @autoDelete,
          bool @internal,
          bool @nowait,
          System.Collections.Generic.IDictionary<string, object> @arguments)
        {
            ExchangeDeclare __req = new ExchangeDeclare();
            __req.m_exchange = @exchange;
            __req.m_type = @type;
            __req.m_passive = @passive;
            __req.m_durable = @durable;
            __req.m_autoDelete = @autoDelete;
            __req.m_internal = @internal;
            __req.m_nowait = @nowait;
            __req.m_arguments = @arguments;
            if (nowait)
            {
                await ModelSendAsync(__req, null, null);
                return;
            }
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            ExchangeDeclareOk __rep = __repBase as ExchangeDeclareOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override async Task _Private_ExchangeDeleteAsync(
          string @exchange,
          bool @ifUnused,
          bool @nowait)
        {
            ExchangeDelete __req = new ExchangeDelete();
            __req.m_exchange = @exchange;
            __req.m_ifUnused = @ifUnused;
            __req.m_nowait = @nowait;
            if (nowait)
            {
                await ModelSendAsync(__req, null, null);
                return;
            }
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            ExchangeDeleteOk __rep = __repBase as ExchangeDeleteOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override  async Task _Private_ExchangeBindAsync(
          string @destination,
          string @source,
          string @routingKey,
          bool @nowait,
          System.Collections.Generic.IDictionary<string, object> @arguments)
        {
            ExchangeBind __req = new ExchangeBind();
            __req.m_destination = @destination;
            __req.m_source = @source;
            __req.m_routingKey = @routingKey;
            __req.m_nowait = @nowait;
            __req.m_arguments = @arguments;
            if (nowait)
            {
                await ModelSendAsync(__req, null, null);
                return;
            }
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            ExchangeBindOk __rep = __repBase as ExchangeBindOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override async Task _Private_ExchangeUnbindAsync(
          string @destination,
          string @source,
          string @routingKey,
          bool @nowait,
          System.Collections.Generic.IDictionary<string, object> @arguments)
        {
            ExchangeUnbind __req = new ExchangeUnbind();
            __req.m_destination = @destination;
            __req.m_source = @source;
            __req.m_routingKey = @routingKey;
            __req.m_nowait = @nowait;
            __req.m_arguments = @arguments;
            if (nowait)
            {
                await ModelSendAsync(__req, null, null);
                return;
            }
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            ExchangeUnbindOk __rep = __repBase as ExchangeUnbindOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override async Task _Private_QueueDeclareAsync(
          string @queue,
          bool @passive,
          bool @durable,
          bool @exclusive,
          bool @autoDelete,
          bool @nowait,
          System.Collections.Generic.IDictionary<string, object> @arguments)
        {
            QueueDeclare __req = new QueueDeclare();
            __req.m_queue = @queue;
            __req.m_passive = @passive;
            __req.m_durable = @durable;
            __req.m_exclusive = @exclusive;
            __req.m_autoDelete = @autoDelete;
            __req.m_nowait = @nowait;
            __req.m_arguments = @arguments;
            //if (nowait)
            //{
            //    await ModelSendAsync(__req, null, null);
            //    return;
            //}
            await ModelSendAsync(__req, null, null);
        }
        public override async Task _Private_QueueBindAsync(
          string @queue,
          string @exchange,
          string @routingKey,
          bool @nowait,
          System.Collections.Generic.IDictionary<string, object> @arguments)
        {
            QueueBind __req = new QueueBind();
            __req.m_queue = @queue;
            __req.m_exchange = @exchange;
            __req.m_routingKey = @routingKey;
            __req.m_nowait = @nowait;
            __req.m_arguments = @arguments;
            if (nowait)
            {
                await ModelSendAsync(__req, null, null);
                return;
            }
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            QueueBindOk __rep = __repBase as QueueBindOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override async Task<uint> _Private_QueuePurgeAsync(
          string @queue,
          bool @nowait)
        {
            QueuePurge __req = new QueuePurge();
            __req.m_queue = @queue;
            __req.m_nowait = @nowait;
            if (nowait)
            {
                await ModelSendAsync(__req, null, null);
                return 0xFFFFFFFF;
            }
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            QueuePurgeOk __rep = __repBase as QueuePurgeOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
            return __rep.m_messageCount;
        }
        public override async Task<uint> _Private_QueueDeleteAsync(
          string @queue,
          bool @ifUnused,
          bool @ifEmpty,
          bool @nowait)
        {
            QueueDelete __req = new QueueDelete();
            __req.m_queue = @queue;
            __req.m_ifUnused = @ifUnused;
            __req.m_ifEmpty = @ifEmpty;
            __req.m_nowait = @nowait;
            if (nowait)
            {
                await ModelSendAsync(__req, null, null);
                return 0xFFFFFFFF;
            }
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            QueueDeleteOk __rep = __repBase as QueueDeleteOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
            return __rep.m_messageCount;
        }
        public override async Task _Private_BasicPublishAsync(
          string @exchange,
          string @routingKey,
          bool @mandatory,
          //bool @immediate,
          RabbitMQ.Client.IBasicProperties @basicProperties,
          byte[] @body)
        {
            BasicPublish __req = new BasicPublish();
            __req.m_exchange = @exchange;
            __req.m_routingKey = @routingKey;
            __req.m_mandatory = @mandatory;
            //__req.m_immediate = @immediate;
            await ModelSendAsync(__req, (BasicProperties)basicProperties, body);
        }

        //public override async Task _Private_BasicPublishAsync(
        //  string @exchange,
        //  string @routingKey,
        //  bool @mandatory,
        //  //bool @immediate,
        //  RabbitMQ.Client.IBasicProperties @basicProperties,
        //  byte[] @body)
        //{
        //    BasicPublish __req = new BasicPublish();
        //    __req.m_exchange = @exchange;
        //    __req.m_routingKey = @routingKey;
        //    __req.m_mandatory = @mandatory;
        //    //__req.m_immediate = @immediate;
        //    await ModelSendAsync(__req, (BasicProperties)basicProperties, body);
        //}
        public override async Task _Private_BasicConsumeAsync(
          string @queue,
          string @consumerTag,
          bool @noLocal,
          bool @noAck,
          bool @exclusive,
          bool @nowait,
          System.Collections.Generic.IDictionary<string, object> @arguments)
        {
            BasicConsume __req = new BasicConsume();
            __req.m_queue = @queue;
            __req.m_consumerTag = @consumerTag;
            __req.m_noLocal = @noLocal;
            __req.m_noAck = @noAck;
            __req.m_exclusive = @exclusive;
            __req.m_nowait = @nowait;
            __req.m_arguments = @arguments;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task _Private_ConfirmSelectAsync(
          bool @nowait)
        {
            ConfirmSelect __req = new ConfirmSelect();
            __req.m_nowait = @nowait;
            if (nowait)
            {
                await ModelSendAsync(__req, null, null);
                return;
            }
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            ConfirmSelectOk __rep = __repBase as ConfirmSelectOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override async Task _Private_BasicCancelAsync(
          string @consumerTag,
          bool @nowait)
        {
            BasicCancel __req = new BasicCancel();
            __req.m_consumerTag = @consumerTag;
            __req.m_nowait = @nowait;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task _Private_ChannelOpenAsync(
          string @outOfBand)
        {
            ChannelOpen __req = new ChannelOpen();
            __req.m_reserved1 = @outOfBand;
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            ChannelOpenOk __rep = __repBase as ChannelOpenOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override Task _Private_ChannelCloseOkAsync()
        {
            return ModelSendAsync(new ChannelCloseOk(), null, null);
        }
        public override async Task _Private_ChannelCloseAsync(
          ushort @replyCode,
          string @replyText,
          ushort @classId,
          ushort @methodId)
        {
            ChannelClose __req = new ChannelClose();
            __req.m_replyCode = @replyCode;
            __req.m_replyText = @replyText;
            __req.m_classId = @classId;
            __req.m_methodId = @methodId;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task _Private_BasicGetAsync(
          string @queue,
          bool @noAck)
        {
            BasicGet __req = new BasicGet();
            __req.m_queue = @queue;
            __req.m_noAck = @noAck;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task _Private_BasicRecoverAsync(
          bool @requeue)
        {
            BasicRecover __req = new BasicRecover();
            __req.m_requeue = @requeue;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task _Private_ChannelFlowOkAsync(
          bool @active)
        {
            ChannelFlowOk __req = new ChannelFlowOk();
            __req.m_active = @active;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task _Private_ConnectionStartOkAsync(
          System.Collections.Generic.IDictionary<string, object> @clientProperties,
          string @mechanism,
          byte[] @response,
          string @locale)
        {
            ConnectionStartOk __req = new ConnectionStartOk();
            __req.m_clientProperties = @clientProperties;
            __req.m_mechanism = @mechanism;
            __req.m_response = @response;
            __req.m_locale = @locale;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task _Private_ConnectionSecureOkAsync(
          byte[] @response)
        {
            ConnectionSecureOk __req = new ConnectionSecureOk();
            __req.m_response = @response;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task QueueUnbindAsync(
          string @queue,
          string @exchange,
          string @routingKey,
          System.Collections.Generic.IDictionary<string, object> @arguments)
        {
            QueueUnbind __req = new QueueUnbind();
            __req.m_queue = @queue;
            __req.m_exchange = @exchange;
            __req.m_routingKey = @routingKey;
            __req.m_arguments = @arguments;
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            QueueUnbindOk __rep = __repBase as QueueUnbindOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override async Task BasicQosAsync(
          uint @prefetchSize,
          ushort @prefetchCount,
          bool @global)
        {
            BasicQos __req = new BasicQos();
            __req.m_prefetchSize = @prefetchSize;
            __req.m_prefetchCount = @prefetchCount;
            __req.m_global = @global;
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            BasicQosOk __rep = __repBase as BasicQosOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override async Task BasicAckAsync(
          ulong @deliveryTag,
          bool @multiple)
        {
            BasicAck __req = new BasicAck();
            __req.m_deliveryTag = @deliveryTag;
            __req.m_multiple = @multiple;
            await ModelSendAsync(__req, null, null);
        }

        public override async Task BasicRejectAsync(
          ulong @deliveryTag,
          bool @requeue)
        {
            BasicReject __req = new BasicReject();
            __req.m_deliveryTag = @deliveryTag;
            __req.m_requeue = @requeue;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task BasicNackAsync(
          ulong @deliveryTag,
          bool @multiple,
          bool @requeue)
        {
            BasicNack __req = new BasicNack();
            __req.m_deliveryTag = @deliveryTag;
            __req.m_multiple = @multiple;
            __req.m_requeue = @requeue;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task BasicRecoverAsyncAsync(
          bool @requeue)
        {
            BasicRecoverAsync __req = new BasicRecoverAsync();
            __req.m_requeue = @requeue;
            await ModelSendAsync(__req, null, null);
        }
        public override async Task TxSelectAsync()
        {
            TxSelect __req = new TxSelect();
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            TxSelectOk __rep = __repBase as TxSelectOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override async Task TxCommitAsync()
        {
            TxCommit __req = new TxCommit();
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            TxCommitOk __rep = __repBase as TxCommitOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
        public override async Task TxRollbackAsync()
        {
            TxRollback __req = new TxRollback();
            RabbitMQ.Client.Impl.MethodBase __repBase = await ModelRpcAsync(__req, null, null);
            TxRollbackOk __rep = __repBase as TxRollbackOk;
            if (__rep == null) throw new UnexpectedMethodException(__repBase);
        }
    }
}